{"title": "wellog-viz 技能优化建议", "type": "易用性改进", "scenario": "1. Readout 面板实现 : 目前实现 Readout（随鼠标移动显示数值）需要手动编写大量 DOM 操作代码 ( document.getElementById , innerHTML )，且需要手动计算 scale.invert(y) 来查找深度对应的值。\n2. 数据生成与绑定 : GraphTrack 需要特定的数据结构，如果原始数据是行式的（Row-based，如 CSV），需要手动转换成列式（Columnar）。", "pain_point": "1. 交互样板代码过多 : 仅仅为了显示一个“当前深度和数值”，开发者需要在 main.ts 中写几十行非核心的 UI 更新逻辑。这在测井应用中是极高频的需求，目前的 API 过于底层。\n2. 数据处理繁琐 : mock-utils.ts 中我们需要手动构建复杂的嵌套对象。如果能有更直观的数据绑定方式会更好。", "suggestion": "1. 内置 Readout 控件 : 建议 wellog-viz 提供一个内置的 ReadoutController 或插件。\n2. 简化 Track 配置 : 对于简单的单曲线 Track，目前的配置层级略深 ( plots: [{ type: 'line', options: { ... } }] )。\n3. Legend 自动生成 : 目前图例信息 ( legendInfo ) 需要在每个 Plot 中手动定义函数返回 { label, unit } 。建议允许在 Track 级别统一定义，或者如果 Plot ID 与数据 Key 一致，自动推导 Label。", "timestamp": "2026-01-22T16:14:44.416941"}
{"title": "wellog-viz 技能优化建议", "type": "易用性改进 / 缺陷修复", "scenario": "在使用 GraphTrack 配置多条曲线（Plots）且传入对象数组格式的数据（Row-oriented Data）时，若未显式为每个 Plot 配置 dataAccessor ，会导致内部报错 datapoints.filter is not a function 。这在“Triple Combo”等复杂场景中非常容易触发，因为用户往往希望直接传入整个数据集。", "pain_point": "目前 GraphTrack 的 Plot 默认行为似乎是直接读取 Track 的 data，而未自动处理对象数组到二维数组 [depth, value] 的转换，导致开发者必须手动为每个 Plot 写重复的 data => data.map(...) 转换函数，增加了样板代码量且容易出错。", "suggestion": "1. 文档优化 : 在 visual-patterns.md 或 examples.md 中，针对“Row Data”场景增加显式的 Warning 或 Best Practice，强调必须配合 dataAccessor 使用。\n2. 工具增强 : 建议 wellog-viz 库或技能提供一个 helper 函数（如 createDataAccessor(key) ），或者在 GraphTrack 层面增加智能推断：如果 data 是对象数组且 Plot ID 匹配 data key，自动提取对应数据列，减少手动编写 accessor 的负担。", "timestamp": "2026-01-22T17:43:49.116311"}
{"title": "wellog-viz 技能优化建议", "type": "易用性改进 / 防御性编程", "scenario": "开发者在使用 requestAnimationFrame 包裹 init() 以确保 DOM 就绪时，容易习惯性地将后续逻辑（如 overlay.create ）写在回调函数外部，导致运行时因时序问题报错。", "pain_point": "LogViewer.init() 是同步方法但依赖 DOM 尺寸，导致必须配合异步的 RAF 使用。这种“半同步半异步”的模式增加了代码结构的复杂度，且报错信息 undefined (reading 'create') 对新手不够直观。", "suggestion": "1. API 优化 : 建议让 viewer.init() 返回一个 Promise 或 this （且内部自动处理 DOM 等待），支持链式调用，例如 viewer.init(div).then(() => viewer.overlay.create(...)) 。\n2. 文档增强 : 在 Skill 的 SOP 中明确强调： 所有 依赖 viewer 实例的方法（setTracks, zoomTo, overlay）都必须严格包裹在同一个初始化闭包/回调中。", "timestamp": "2026-01-22T17:47:19.208628"}
{"title": "wellog-viz 技能优化建议", "type": "易用性改进 / 风险警示", "scenario": "在 React useEffect 中初始化 LogViewer 时，开发者通常使用 requestAnimationFrame (RAF) 来确保 DOM 节点已挂载。然而，常见的错误模式是将 viewer.init() 放在 RAF 回调中，却将 viewer.overlay.create() 或 setTracks() 放在 RAF 外部同步执行。\n此外，若不处理 useEffect 的清理函数（cleanup）来取消 RAF，在 React 严格模式（StrictMode）或快速切换路由时，会导致竞态条件，同时存在多个 Viewer 实例，引发“空白屏幕”或“闪烁”问题。", "pain_point": "1. 时序陷阱 ： viewer.init() 依赖 DOM 尺寸，必须异步等待；而 overlay 等 API 又依赖 init 完成。当前的 API 设计导致用户必须手动编写复杂的嵌套回调或 RAF 逻辑，极易出错（如本次遇到的 undefined reading 'create' ）。\n2. 竞态风险 ：缺乏内置的生命周期管理工具，开发者必须手动维护 rafId 并在组件卸载时清理，否则会造成内存泄漏和渲染异常。\n3. 数据门槛 ： GraphTrack 默认仅支持列式数据或需手动编写 dataAccessor ，对于通用的行式数据（Row-based data）缺乏自动推断支持，导致渲染不出图像且无报错。", "suggestion": "1. 工具增强 (Feature) ：建议在技能中增加一个 React Hook 封装示例（如 useLogViewer ）或通用 Helper 函数（如 LogViewer.mount(container, options) ），该函数应：\n   - 自动处理 requestAnimationFrame 等待 DOM 就绪。\n   - 返回一个 Promise ，resolve 为初始化完成的 Viewer 实例，允许用户使用 await viewer.mount(...); viewer.overlay.create(...) 的线性逻辑。\n   - 自动处理清理/销毁逻辑（dispose/destroy）。\n2. 文档优化 (Doc) ：在 BEST_PRACTICES.md 中增加“React 集成标准范式”，明确展示带有 cancelAnimationFrame 的完整代码片段，并用粗体警示“所有交互层创建必须在 init 回调内部执行”。\n3. 智能数据 (Feature) ：建议 GraphTrack 增加对 Row-based 数据的原生支持，自动识别并提取对应字段，减少 transformToColumnar 样板代码。", "timestamp": "2026-01-22T17:56:57.674962"}
{"title": "wellog-viz 技能优化建议", "type": "易用性改进 / 风险警示", "scenario": "用户在使用 React 开发时，直接在 useEffect 中同步初始化 LogViewer ，且未处理 StrictMode 的双重挂载问题，导致页面白屏。同时，若父容器未明确高度，Canvas 可能会初始化失败。", "pain_point": "videx-wellog 是基于直接 DOM 操作的，与 React 的声明式渲染和 StrictMode 机制天然冲突。开发者必须编写大量样板代码（RAF, cleanup, isActive guard）来适配。", "suggestion": "1. 提供 React Hook : 建议封装一个官方的 useLogViewer(containerRef, options) Hook，内部处理 RAF 等待、StrictMode 防抖和清理逻辑。\n2. 文档增强 : 在“Getting Started”中明确强调 React 集成的注意事项，甚至直接提供一个 ReactWrapper 组件示例。\n3. 调试工具 : 在 LogViewer 内部增加检测：如果 init(el) 被调用时 el.clientHeight 为 0，应在控制台输出警告 \"LogViewer initialized on zero-height element\"。", "timestamp": "2026-01-22T21:59:11.469120"}
{"title": "wellog-viz 技能优化建议", "type": "缺陷修复 / 风险警示", "scenario": "用户在初始化 LogViewer 时未指定 domain ，默认为 [0, 1000] 。随后通过 zoomTo 跳转到了深井段（如 4000m）。当用户触发任何交互（如滚动）时， ScaleHandler 可能会基于原始默认 domain 重新计算坐标，导致视图瞬间“弹飞”或空白，因为当前视口完全在默认范围之外。", "pain_point": "这是一个隐蔽的逻辑陷阱，开发者往往认为 zoomTo 已经设置了范围，却忽略了底层的 domain 约束。", "suggestion": "1. 防御性编程 : 建议在 wellog-viz 的 LogViewer 类中增加警告：如果 zoomTo 的范围完全超出了构造函数设定的 domain ，应在控制台输出警告 \"Zoom range is outside the configured domain. Interaction may be unstable.\"\n2. 文档强调 : 在“最佳实践”文档中加粗强调： 必须在构造函数中设置覆盖全井段的 domain ，而不仅是依赖 zoomTo 。", "timestamp": "2026-01-22T22:10:02.036468"}
{"title": "文档索引优化 / 最佳实践可发现性", "type": "文档优化 / 易用性改进", "scenario": "用户发现部分 AI 无法正确索引到最佳实践文档 (references/best-practices.md)，导致相关知识点（如 Domain 配置、React 集成）未被有效利用。", "pain_point": "关键的最佳实践（SOPs、常见陷阱）如果不能被 AI 检索到，就无法在用户遇到问题时主动提供帮助，导致重复的低级错误。", "suggestion": "评估文档结构，考虑重命名、移动或增加显式引用，以提高 AI 索引权重。", "timestamp": "2026-01-22T22:21:10.983075"}
{"title": "SKILL.md 结构优化 / 文档层级", "type": "文档优化", "scenario": "用户希望在 SKILL.md 中明确区分 \"Best Practices\" (What/Why) 和 \"High-Level Abstractions\" (How/Tools) 的定位，以便开发者更清晰地知道何时查阅哪个文档。", "pain_point": "当前文档列表只是简单的罗列，缺乏对两者关系的解释，开发者可能困惑于“最佳实践”和“高级抽象”之间的界限。", "suggestion": "在 SKILL.md 中明确两者的分工：BEST_PRACTICES.md 是“避坑指南与规范”，HIGH_LEVEL_ABSTRACTIONS.md 是“工具箱与实现”。", "timestamp": "2026-01-22T22:26:48.828014"}
{"title": "wellog-viz 技能优化建议", "type": "易用性改进", "scenario": "在使用 StackedTrack 时，遇到运行时错误 TypeError: options.data is not a function 。", "pain_point": "StackedTrack 的 data 属性必须是一个返回 Promise 的函数（例如 () => Promise.resolve(data) ），而非常规数组。这一约束在 TS 类型定义中可能不够直观（或被视为 any ），容易导致开发者直接传入数组而报错。", "suggestion": "文档/逻辑优化: 建议在 wellog-viz 的 examples.md 或常见问题中，显著标注 StackedTrack 的数据加载模式必须为异步函数。同时建议在技能输出的 StackedTrack 代码片段中默认加上 Promise.resolve 包装。", "timestamp": "2026-01-22T22:39:43.148152"}
